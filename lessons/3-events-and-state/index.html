<meta charset='utf-8'>
<style>html {
  background: #242331;
  padding-top: 3px;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
}

*,
*:before,
*:after {
  box-sizing: inherit;
  -moz-box-sizing: inherit;
  -webkit-box-sizing: inherit;
}

body {
  background: #fff;
  color: #333;
  font-family: "Roboto Draft", "Roboto", -apple-system, BlinkMacSystemFont, "Segoe UI", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
  font-size: 14px;
  font-weight: 400;
  line-height: 20px;
  margin: 0;
  padding-bottom: 40px;
  padding-top: 24px;
  position: relative;
}

/* body:before { */
/*   position: absolute; */
/*   content: ""; */
/*   background-size: 4px 4px; */
/*   background-image: linear-gradient(0deg, transparent, red 1px, transparent 1px, transparent 4px), linear-gradient(90deg, transparent, red 1px, transparent 1px, transparent 4px); */
/*   left: 0; */
/*   right: 0; */
/*   top: 0; */
/*   height: 99999px; */
/*   z-index: 100000; */
/*   mix-blend-mode: difference; */
/*   pointer-events: none; */
/* } */

p, div, section, main, ul, ol, dl, h1, h2, h3, h4, h5, h6, pre code, blockquote, iframe {
  display: block;
  margin-left: auto;
  margin-right: auto;
  max-width: 550px;
  padding-left: 16px;
  padding-right: 16px;
}

img {
  display: block;
  max-width: 100%;
}

iframe {
  border-radius: 2px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
  padding: 0;
  margin: 16px auto 32px;
}

h1, h2, h3 {
  -webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;
}

h1, h2, h3, h4, h5, h6 {
  color: #242331;
}

ol, ul {
  line-height: 20px;
  margin-top: 0;
  margin-bottom: 8px;
}

li {
  display: table;
  list-style: none;
}

li:before {
  display: table-cell;
  opacity: 0.54;
  text-align: right;
  padding-right: 12px;
  width: 12px;
}

ul > li:before {
  content: "•";
}

ol {
  counter-reset: ordered
}

ol > li:before {
  content: counter(ordered) ".";
  counter-increment: ordered;
}

li p:first-child {
  margin-top: 0;
}

li p {
  padding: 0 0 16px;
}

h1 {
  font-size: 34px;
  font-weight: 500;
  line-height: 48px;
  margin: 32px auto 56px;
}

h2 {
  font-size: 24px;
  font-weight: 500;
  line-height: 44px;
  margin-top: 12px;
  margin-bottom: 12px;
}

h3 {
  font-size: 20px;
  font-weight: 600;
  line-height: 44px;
  margin-top: 12px;
}

h4 {
  font-size: 16px;
  font-weight: 400;
  line-height: 32px;
}

h5, h6 {
  font-size: 14px;
  font-weight: 600;
  line-height: 32px;
}

p {
  line-height: 24px;
  margin: 0 auto;
  padding: 12px 16px 24px;
  hyphens: auto;
  -webkit-hyphens: auto;
}

p + p {
  padding-top: 0;
}

code {
  color: #c7254e;
  font-size: 12px;
  padding: 2px;
  background-color: #f9f2f4;
}

pre {
  background: #242331;
  padding: 38px 16px;
  line-height: 20px;
  margin: 20px 0 36px;
  overflow: auto;
}

pre code {
  background: transparent;
  color: #ECECF6;
  border-radius: 0;
  font-size: 13px;
  font-family: 'Inconsolata', "Lucida Console", Monaco, monospace;
  padding: 0 20px;
}

a {
  color: inherit;
  transition: 0.3s all;
  text-decoration: underline dotted;
}

a:hover,
a:focus {
  color: #44f;
  transition: 0.1s all;
}

blockquote {
  border-left: 8px solid #ccc;
  margin: 40px auto;
  quotes: "\201C""\201D""\2018""\2019";
  font-style: italic;
  font-family: 'Georgia', serif;
  font-size: 110%;
  color: #666;
  padding: 8px 0 1px 12px;
}

hr {
  border: 0;
  border-bottom: 1px dotted #ccc;
  margin: 48px 0;
}

table {
  border: 1px solid #d9d9d9;
  border-radius: 2px;
  border-spacing: 0;
  max-width: 700px;
  margin: 40px auto;
  padding: 8px 16px;
  width: 100%;
}

table thead th {
  border-bottom: 1px solid #d9d9d9;
  text-align: left;
}

table td,
table th {
  padding: 12px 24px 8px 0;
  vertical-align: top;
}

/**
 * Tomorrow Night Theme
 * http://jmblog.github.com/color-themes-for-google-code-highlightjs
 * Original theme - https://github.com/chriskempson/tomorrow-theme
 * http://jmblog.github.com/color-themes-for-google-code-highlightjs
 */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
  color: #969896;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
  color: #cc6666;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
  color: #de935f;
}

/* Tomorrow Yellow */
.hljs-attribute {
  color: #f0c674;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
  color: #b5bd68;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
  color: #81a2be;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
  color: #b294bb;
}

.hljs {
  display: block;
  overflow-x: auto;
  background: #1d1f21;
  color: #c5c8c6;
  padding: 0.5em;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}
</style><h1 id="events-and-state">Events and State</h1>
<p>Applications are interactive. In this lesson we’ll learn how to listen to user
feedback. We’ll also learn about a new way for components to keep track of
things: internal state.</p>
<p>Right now our application looks something like:</p>
<pre><code class="lang-html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Learning React<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"lib/style.css"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"entry-point"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"lib/react.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"lib/react-dom.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"lib/babel.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/babel"</span>&gt;</span><span class="actionscript">
      <span class="hljs-keyword">var</span> notes = [
        { id: <span class="hljs-number">1</span>, content: <span class="hljs-string">'Learn React'</span> },
        { id: <span class="hljs-number">2</span>, content: <span class="hljs-string">'Get Lunch'</span> },
        { id: <span class="hljs-number">3</span>, content: <span class="hljs-string">'Learn React Native'</span> }
      ]

      <span class="hljs-keyword">var</span> Note = React.createClass({
        render() {
          <span class="hljs-keyword">return</span> &lt;li&gt;{ <span class="hljs-keyword">this</span>.props.content }&lt;/li&gt;
        }
      })

      <span class="hljs-keyword">var</span> NotesList = React.createClass({
        renderNote(note) {
          <span class="hljs-keyword">return</span> &lt;Note key={ note.id } content={ note.content } /&gt;
        },
        render() {
          <span class="hljs-keyword">return</span> &lt;ul&gt;{ <span class="hljs-keyword">this</span>.props.notes.map(<span class="hljs-keyword">this</span>.renderNote) }&lt;/ul&gt;
        }
      })

      <span class="hljs-keyword">var</span> App = React.createClass({
        render() {
          <span class="hljs-keyword">var</span> notes = <span class="hljs-keyword">this</span>.props.notes

          <span class="hljs-keyword">return</span> (
            &lt;section&gt;
              &lt;h1&gt;You have { notes.length }&lt;/h1&gt;
              &lt;NotesList notes={ notes } /&gt;
            &lt;/section&gt;
          )
        }
      })

      ReactDOM.render(&lt;App notes={ notes } /&gt;, document.getElementById(<span class="hljs-string">'entry-point'</span>))
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>This code helped us to learn about React elements, components, and the JSX
syntax for quickly writing React code. However it isn’t interactive.</p>
<h2 id="building-a-form-for-notes">Building a form for notes</h2>
<p>Event handlers are configured as props, just like anything else. Let’s make a
new component to handle creating new notes</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> NotesForm = React.createClass({
  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> (
      &lt;form ref="form" onSubmit={this.handleSubmission}&gt;
        &lt;input type="text" ref="content" /&gt;
        &lt;input type="submit" value="Add Note" /&gt;
      &lt;/form&gt;
    )
  },

  handleSubmission: function(event) {
    event.preventDefault()
    this.props.onSubmit(this.refs.content)
    this.refs.form.reset()
  }
})
</code></pre>
<p>There are a couple of new things here. First, sending the <code>onSubmit</code> prop to the
<code>&lt;form&gt;</code> element in the <code>render</code> function creates an event listener for that
element.</p>
<p>This approach works, in practice, exactly like if you were to set
<code>form.onsubmit</code> with a callback. In actuality, React sets up a delegated event
handler on the <code>window</code>. When the form submits, the event will bubble up to the
window, where React will intercept it and communicate the event to its elements.</p>
<p>React calls this the
<a href="https://facebook.github.io/react/docs/events.html"><em>Synthetic Event System</em></a>.
We won’t dig too much deeper into this, but it is an interesting area of study
for those curious.</p>
<h2 id="what-is-a-ref-">What is a ref?</h2>
<p>There’s another new concept: the <code>ref</code> prop. The <code>ref</code> prop acts as a pointer to
a place in the component tree:</p>
<pre><code class="lang-javascript">handleSubmission: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
  <span class="hljs-comment">//...</span>
  <span class="hljs-keyword">this</span>.refs.form.reset()
  <span class="hljs-comment">//...</span>
}
</code></pre>
<p>In our render method, we assigned a ref of <code>&quot;form&quot;</code> to the form element. This
lets us access it directly in other places. Refs are a great way to quickly
retrieve information about a component.</p>
<h2 id="hooking-up-the-notes-form">Hooking up the notes form</h2>
<p>Now that we have our form, let’s add it to the <code>App</code> component:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> App = React.createClass({
  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> (
      &lt;section&gt;
        &lt;h1&gt;You have {this.props.notes.length} notes&lt;/h1&gt;
        &lt;NotesList notes={this.props.notes} /&gt;
        &lt;NotesForm onSubmit={this.formWasSubmitted} /&gt;
      &lt;/section&gt;
    )
  },
  formWasSubmitted: function(content) {
    alert("New note: " + content)
  }
})
</code></pre>
<p>When the form is submitted, we’ve told it to execute the <code>formWasSubmitted</code>
callback inside of <code>App</code>. Go ahead and give this a try.</p>
<p>Of course, simply alerting that the note should be created doesn’t get us very
far. In order to continue, we need to talk about a new form of component data:
<em>state</em>`.</p>
<h2 id="props-and-state">Props and State</h2>
<p>React components have two types of properties: props and state.</p>
<p><strong>Props are given to a component.</strong> The only control a component has over their
props is how to inform its children about them.</p>
<p><strong>State is internal to a component.</strong> This is useful for keeping track of
component local data. For example, drop-downs must be able to keep track of if
they are open our not.</p>
<p>Our application needs to keep track of notes. Let’s configure the <code>App</code>
component with some internal state:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> App = React.createClass({
  <span class="hljs-comment">// Move notes from the top of the script into here</span>
  getInitialState: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    notes: [
      { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">"Learn React"</span> },
      { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">"Get Lunch"</span> },
      { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">"Learn React Native"</span> }
    ]
  },
  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> (
      &lt;section&gt;
        &lt;h1&gt;You have {this.state.notes.length} notes&lt;/h1&gt;
        &lt;NotesList notes={this.state.notes} /&gt;
        &lt;NotesForm onSubmit={this.formWasSubmitted} /&gt;
      &lt;/section&gt;
    )
  },
  formWasSubmitted: function(content) {
    var note = {
      id: Date.now().toString(), // cheap trick for unique ids, don't do this in production!
      content: content
    }

    this.setState({
      notes: this.state.notes.concat(note)
    })
  }
})
</code></pre>
<p>First, we add <code>getInitialState</code>, a function that runs whenever a component is
first created with <code>React.createElement</code>. It determines the initial value of the
component’s internal state object.</p>
<p>Second, we replace all instances of <code>this.props.notes</code> with <code>this.state.notes</code>.
Notes will be managed internally to the <code>App</code>.</p>
<p>Third, we use a method we haven’t covered yet: <code>setState</code>. <code>setState</code> queues up
a request to merge a provided object into the component’s internal state. This
is <em>additive</em>, meaning that any other keys in the state object won’t be blown
away.</p>
<p>As a final step, we no longer need to send notes in as a prop to <code>App</code>, so let’s
update our render method:</p>
<pre><code class="lang-javascript">ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> <span class="hljs-attr">notes</span>=<span class="hljs-string">{notes}</span> /&gt;</span>, document.getElementById("entry-point"))</span>
</code></pre>
<h2 id="removing-notes">Removing notes</h2>
<p>Adding all the notes we want is useful, but removing notes is an important
feature of any full-featured note application. We’ve learned everything about
React that we need to get there.</p>
<p>Let’s work our way down from the <code>App</code> component, adding this functionality the
associated children. First, pass an <code>onDelete</code> prop into the <code>NotesList</code>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> App = React.createClass({
  <span class="hljs-comment">//...</span>
  render: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> (
      &lt;section&gt;
        &lt;h1&gt;You have {this.props.notes.length} notes&lt;/h1&gt;
        &lt;NotesList notes={this.props.notes} onDelete={this.noteWasDestroyed} /&gt;
        &lt;NotesForm onSubmit={this.formWasSubmitted} /&gt;
      &lt;/section&gt;
    )
  },
  // ...
  noteWasDestroyed: function(id) {
    this.setState({
      notes: this.state.notes.filter(function(note) {
        return note.id !== id
      })
    })
  }
})
</code></pre>
<p>Easy enough, whenever the <code>NotesList</code> invokes the callback we provide to it as
an <code>onDelete</code> prop, we will filter out all notes that match the id it provides.</p>
<p>Speaking of the <code>NotesList</code>, we need to teach it about the <code>onDelete</code> prop:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> NotesList = React.createClass({
  <span class="hljs-attr">renderNote</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">note</span>) </span>{
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Note</span>
        <span class="hljs-attr">key</span>=<span class="hljs-string">{note.id}</span>
        <span class="hljs-attr">id</span>=<span class="hljs-string">{note.id}</span>
        <span class="hljs-attr">content</span>=<span class="hljs-string">{note.content}</span>
        <span class="hljs-attr">onDelete</span>=<span class="hljs-string">{this.props.onDelete}</span>
      /&gt;</span>
    )
  }
  //...
})</span>
</code></pre>
<p>Easy enough, we add an <code>id</code> prop to the <code>&lt;Note /&gt;</code>, and also send to it the
<code>onDelete</code> callback from the parent.</p>
<p>However the <code>Note</code> itself isn’t deletable. As a final step, let’s add a button
to the <code>Note</code> component that allows the user to trigger this interaction:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> Note = React.createClass({
  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
        {this.props.content}
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.onDeleteClick}</span>&gt;</span>
          Remove
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
    )
  },
  onDeleteClick(event) {
    event.preventDefault()
    <span class="hljs-keyword">this</span>.props.onDelete(<span class="hljs-keyword">this</span>.props.id)
  }
})
</code></pre>
<p>That’s it! Whenever the button is clicked, the <code>Note</code> component will handle the
specific implementation details of responding to the user’s interaction, then
communicate the important information via the <code>onDelete</code> callback function.</p>
<h2 id="one-way-data-flow">One way data flow</h2>
<p>In order to add the delete functionality, we had to touch 3 components. Even if
this felt a little cumbersome, the flow of properties is extremely clear. As we
walked deeper into the component tree, information about the application quickly
faded away. Components such as <code>Note</code> don’t even care about a <code>note</code> record at
all, simply the idea of a chunk of information with an <code>id</code> and `content.</p>
<h2 id="props-are-easy-to-test">Props are easy to test</h2>
<p>As an aside, the benefit to this approach is that testing these callbacks is
quite straightforward:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">canNotifyUserDeleteIntent</span>(<span class="hljs-params">id</span>) </span>{
  <span class="hljs-built_in">console</span>.assert(id, <span class="hljs-string">"2"</span>)
}

<span class="hljs-keyword">var</span> note = ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Note</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"2"</span> <span class="hljs-attr">onDelete</span>=<span class="hljs-string">{canNotifyUserDeleteIntent}</span> /&gt;</span>,
  document.getElementById("entry-point")
)

note.refs.button.click()</span>
</code></pre>
<p><strong>Clear inputs and outputs</strong> make React components both easy to reason about and
easy to test.</p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>In this lesson, we learned about props and state, the React synthetic event
system, and fleshed out more of our application. We touched briefly on
<code>getInitialState</code>, which is a function that runs whenever a component is first
created.</p>
<p>That’s it! If we have extra time, or you have additionally curiosity, checkout
lesson 4, where we explore some new language features in JavaScript and
alternative patterns for writing React components.</p>
<hr>
<p><a href="../4-pascal-bonus/index.html">Lesson 5</a></p>

